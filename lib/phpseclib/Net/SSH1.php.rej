--- lib/phpseclib/Net/SSH1.php
+++ lib/phpseclib/Net/SSH1.php
@@ -1,263 +1,230 @@
 <?php
-/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */
 
 /**
  * Pure-PHP implementation of SSHv1.
  *
- * PHP versions 4 and 5
+ * PHP version 5
  *
  * Here's a short example of how to use this library:
  * <code>
  * <?php
- *    include('Net/SSH1.php');
+ *    include 'vendor/autoload.php';
  *
- *    $ssh = new Net_SSH1('www.domain.tld');
+ *    $ssh = new \phpseclib\Net\SSH1('www.domain.tld');
  *    if (!$ssh->login('username', 'password')) {
  *        exit('Login Failed');
  *    }
  *
- *    while (true) {
- *        echo $ssh->interactiveRead();
- *
- *        $read = array(STDIN);
- *        $write = $except = NULL;
- *        if (stream_select($read, $write, $except, 0)) {
- *            $ssh->interactiveWrite(fread(STDIN, 1));
- *        }
- *    }
+ *    echo $ssh->exec('ls -la');
  * ?>
  * </code>
  *
  * Here's another short example:
  * <code>
  * <?php
- *    include('Net/SSH1.php');
+ *    include 'vendor/autoload.php';
  *
- *    $ssh = new Net_SSH1('www.domain.tld');
+ *    $ssh = new \phpseclib\Net\SSH1('www.domain.tld');
  *    if (!$ssh->login('username', 'password')) {
  *        exit('Login Failed');
  *    }
  *
- *    echo $ssh->exec('ls -la');
+ *    echo $ssh->read('username@username:~$');
+ *    $ssh->write("ls -la\n");
+ *    echo $ssh->read('username@username:~$');
  * ?>
  * </code>
  *
- * More information on the SSHv1 specification can be found by reading 
+ * More information on the SSHv1 specification can be found by reading
  * {@link http://www.snailbook.com/docs/protocol-1.5.txt protocol-1.5.txt}.
  *
- * LICENSE: This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA  02111-1307  USA
- *
- * @category   Net
- * @package    Net_SSH1
- * @author     Jim Wigginton <terrafrost@php.net>
- * @copyright  MMVII Jim Wigginton
- * @license    http://www.gnu.org/licenses/lgpl.txt
- * @version    $Id: SSH1.php,v 1.15 2010/03/22 22:01:38 terrafrost Exp $
- * @link       http://phpseclib.sourceforge.net
- */
-
-/**
- * Include Math_BigInteger
- *
- * Used to do RSA encryption.
- */
-require_once('phpseclib/Math/BigInteger.php');
-
-/**
- * Include Crypt_Null
+ * @category  Net
+ * @package   SSH1
+ * @author    Jim Wigginton <terrafrost@php.net>
+ * @copyright 2007 Jim Wigginton
+ * @license   http://www.opensource.org/licenses/mit-license.html  MIT License
+ * @link      http://phpseclib.sourceforge.net
  */
-//require_once('Crypt/Null.php');
 
-/**
- * Include Crypt_DES
- */
-require_once('phpseclib/Crypt/DES.php');
+namespace phpseclib\Net;
 
-/**
- * Include Crypt_TripleDES
- */
-require_once('phpseclib/Crypt/TripleDES.php');
+use phpseclib\Crypt\DES;
+use phpseclib\Crypt\Random;
+use phpseclib\Crypt\TripleDES;
+use phpseclib\Math\BigInteger;
 
 /**
- * Include Crypt_RC4
- */
-require_once('phpseclib/Crypt/RC4.php');
-
-/**
- * Include Crypt_Random
- */
-require_once('phpseclib/Crypt/Random.php');
-
-/**#@+
- * Protocol Flags
- *
- * @access private
- */
-define('NET_SSH1_MSG_DISCONNECT',          1);
-define('NET_SSH1_SMSG_PUBLIC_KEY',         2);
-define('NET_SSH1_CMSG_SESSION_KEY',        3);
-define('NET_SSH1_CMSG_USER',               4);
-define('NET_SSH1_CMSG_AUTH_PASSWORD',      9);
-define('NET_SSH1_CMSG_REQUEST_PTY',       10);
-define('NET_SSH1_CMSG_EXEC_SHELL',        12);
-define('NET_SSH1_CMSG_EXEC_CMD',          13);
-define('NET_SSH1_SMSG_SUCCESS',           14);
-define('NET_SSH1_SMSG_FAILURE',           15);
-define('NET_SSH1_CMSG_STDIN_DATA',        16);
-define('NET_SSH1_SMSG_STDOUT_DATA',       17);
-define('NET_SSH1_SMSG_STDERR_DATA',       18);
-define('NET_SSH1_SMSG_EXITSTATUS',        20);
-define('NET_SSH1_CMSG_EXIT_CONFIRMATION', 33);
-/**#@-*/
-
-/**#@+
- * Encryption Methods
- *
- * @see Net_SSH1::getSupportedCiphers()
- * @access public
- */
-/**
- * No encryption
- *
- * Not supported.
- */
-define('NET_SSH1_CIPHER_NONE',       0);
-/**
- * IDEA in CFB mode
- *
- * Not supported.
- */
-define('NET_SSH1_CIPHER_IDEA',       1);
-/**
- * DES in CBC mode
- */
-define('NET_SSH1_CIPHER_DES',        2);
-/**
- * Triple-DES in CBC mode
- *
- * All implementations are required to support this
- */
-define('NET_SSH1_CIPHER_3DES',       3);
-/**
- * TRI's Simple Stream encryption CBC
- *
- * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, does define it (see cipher.h),
- * although it doesn't use it (see cipher.c)
- */
-define('NET_SSH1_CIPHER_BROKEN_TSS', 4);
-/**
- * RC4
- *
- * Not supported.
- *
- * @internal According to the SSH1 specs:
- *
- *        "The first 16 bytes of the session key are used as the key for
- *         the server to client direction.  The remaining 16 bytes are used
- *         as the key for the client to server direction.  This gives
- *         independent 128-bit keys for each direction."
- *
- *     This library currently only supports encryption when the same key is being used for both directions.  This is
- *     because there's only one $crypto object.  Two could be added ($encrypt and $decrypt, perhaps).
- */
-define('NET_SSH1_CIPHER_RC4',        5);
-/**
- * Blowfish
+ * Pure-PHP implementation of SSHv1.
  *
- * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, defines it (see cipher.h) and
- * uses it (see cipher.c)
+ * @package SSH1
+ * @author  Jim Wigginton <terrafrost@php.net>
+ * @access  public
  */
-define('NET_SSH1_CIPHER_BLOWFISH',   6);
-/**#@-*/
+class SSH1
+{
+    /**#@+
+     * Encryption Methods
+     *
+     * @see \phpseclib\Net\SSH1::getSupportedCiphers()
+     * @access public
+     */
+    /**
+     * No encryption
+     *
+     * Not supported.
+     */
+    const CIPHER_NONE = 0;
+    /**
+     * IDEA in CFB mode
+     *
+     * Not supported.
+     */
+    const CIPHER_IDEA = 1;
+    /**
+     * DES in CBC mode
+     */
+    const CIPHER_DES = 2;
+    /**
+     * Triple-DES in CBC mode
+     *
+     * All implementations are required to support this
+     */
+    const CIPHER_3DES = 3;
+    /**
+     * TRI's Simple Stream encryption CBC
+     *
+     * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, does define it (see cipher.h),
+     * although it doesn't use it (see cipher.c)
+     */
+    const CIPHER_BROKEN_TSS = 4;
+    /**
+     * RC4
+     *
+     * Not supported.
+     *
+     * @internal According to the SSH1 specs:
+     *
+     *        "The first 16 bytes of the session key are used as the key for
+     *         the server to client direction.  The remaining 16 bytes are used
+     *         as the key for the client to server direction.  This gives
+     *         independent 128-bit keys for each direction."
+     *
+     *     This library currently only supports encryption when the same key is being used for both directions.  This is
+     *     because there's only one $crypto object.  Two could be added ($encrypt and $decrypt, perhaps).
+     */
+    const CIPHER_RC4 = 5;
+    /**
+     * Blowfish
+     *
+     * Not supported nor is it defined in the official SSH1 specs.  OpenSSH, however, defines it (see cipher.h) and
+     * uses it (see cipher.c)
+     */
+    const CIPHER_BLOWFISH = 6;
+    /**#@-*/
 
-/**#@+
- * Authentication Methods
- *
- * @see Net_SSH1::getSupportedAuthentications()
- * @access public
- */
-/**
- * .rhosts or /etc/hosts.equiv
- */
-define('NET_SSH1_AUTH_RHOSTS',     1);
-/**
- * pure RSA authentication
- */
-define('NET_SSH1_AUTH_RSA',        2);
-/**
- * password authentication
- *
- * This is the only method that is supported by this library.
- */
-define('NET_SSH1_AUTH_PASSWORD',   3);
-/**
- * .rhosts with RSA host authentication
- */
-define('NET_SSH1_AUTH_RHOSTS_RSA', 4);
-/**#@-*/
+    /**#@+
+     * Authentication Methods
+     *
+     * @see \phpseclib\Net\SSH1::getSupportedAuthentications()
+     * @access public
+    */
+    /**
+     * .rhosts or /etc/hosts.equiv
+     */
+    const AUTH_RHOSTS = 1;
+    /**
+     * pure RSA authentication
+     */
+    const AUTH_RSA = 2;
+    /**
+     * password authentication
+     *
+     * This is the only method that is supported by this library.
+     */
+    const AUTH_PASSWORD = 3;
+    /**
+     * .rhosts with RSA host authentication
+     */
+    const AUTH_RHOSTS_RSA = 4;
+    /**#@-*/
 
-/**#@+
- * Terminal Modes
- *
- * @link http://3sp.com/content/developer/maverick-net/docs/Maverick.SSH.PseudoTerminalModesMembers.html
- * @access private
- */
-define('NET_SSH1_TTY_OP_END',  0);
-/**#@-*/
+    /**#@+
+     * Terminal Modes
+     *
+     * @link http://3sp.com/content/developer/maverick-net/docs/Maverick.SSH.PseudoTerminalModesMembers.html
+     * @access private
+    */
+    const TTY_OP_END = 0;
+    /**#@-*/
 
-/**
- * The Response Type
- *
- * @see Net_SSH1::_get_binary_packet()
- * @access private
- */
-define('NET_SSH1_RESPONSE_TYPE', 1);
+    /**
+     * The Response Type
+     *
+     * @see \phpseclib\Net\SSH1::_get_binary_packet()
+     * @access private
+     */
+    const RESPONSE_TYPE = 1;
 
-/**
- * The Response Data
- *
- * @see Net_SSH1::_get_binary_packet()
- * @access private
- */
-define('NET_SSH1_RESPONSE_DATA', 2);
+    /**
+     * The Response Data
+     *
+     * @see \phpseclib\Net\SSH1::_get_binary_packet()
+     * @access private
+     */
+    const RESPONSE_DATA = 2;
 
-/**#@+
- * Execution Bitmap Masks
- *
- * @see Net_SSH1::bitmap
- * @access private
- */
-define('NET_SSH1_MASK_CONSTRUCTOR', 0x00000001);
-define('NET_SSH1_MASK_LOGIN',       0x00000002);
-define('NET_SSH1_MASK_SHELL',       0x00000004);
-/**#@-*/
+    /**#@+
+     * Execution Bitmap Masks
+     *
+     * @see \phpseclib\Net\SSH1::bitmap
+     * @access private
+    */
+    const MASK_CONSTRUCTOR = 0x00000001;
+    const MASK_CONNECTED   = 0x00000002;
+    const MASK_LOGIN       = 0x00000004;
+    const MASK_SHELL       = 0x00000008;
+    /**#@-*/
+
+    /**#@+
+     * @access public
+     * @see \phpseclib\Net\SSH1::getLog()
+    */
+    /**
+     * Returns the message numbers
+     */
+    const LOG_SIMPLE = 1;
+    /**
+     * Returns the message content
+     */
+    const LOG_COMPLEX = 2;
+    /**
+     * Outputs the content real-time
+     */
+    const LOG_REALTIME = 3;
+    /**
+     * Dumps the content real-time to a file
+     */
+    const LOG_REALTIME_FILE = 4;
+    /**#@-*/
+
+    /**#@+
+     * @access public
+     * @see \phpseclib\Net\SSH1::read()
+    */
+    /**
+     * Returns when a string matching $expect exactly is found
+     */
+    const READ_SIMPLE = 1;
+    /**
+     * Returns when a string matching the regular expression $expect is found
+     */
+    const READ_REGEX = 2;
+    /**#@-*/
 
-/**
- * Pure-PHP implementation of SSHv1.
- *
- * @author  Jim Wigginton <terrafrost@php.net>
- * @version 0.1.0
- * @access  public
- * @package Net_SSH1
- */
-class Net_SSH1 {
     /**
      * The SSH identifier
      *
-     * @var String
+     * @var string
      * @access private
      */
     var $identifier = 'SSH-1.5-phpseclib';
@@ -265,7 +232,7 @@ class Net_SSH1 {
     /**
      * The Socket Object
      *
-     * @var Object
+     * @var object
      * @access private
      */
     var $fsock;
@@ -273,7 +240,7 @@ class Net_SSH1 {
     /**
      * The cryptography object
      *
-     * @var Object
+     * @var object
      * @access private
      */
     var $crypto = false;
@@ -281,10 +248,10 @@ class Net_SSH1 {
     /**
      * Execution Bitmap
      *
-     * The bits that are set reprsent functions that have been called already.  This is used to determine
+     * The bits that are set represent functions that have been called already.  This is used to determine
      * if a requisite function has been successfully executed.  If not, an error should be thrown.
      *
-     * @var Integer
+     * @var int
      * @access private
      */
     var $bitmap = 0;
@@ -294,8 +261,8 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getServerKeyPublicExponent()
-     * @var String
+     * @see self::getServerKeyPublicExponent()
+     * @var string
      * @access private
      */
     var $server_key_public_exponent;
@@ -305,8 +272,8 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getServerKeyPublicModulus()
-     * @var String
+     * @see self::getServerKeyPublicModulus()
+     * @var string
      * @access private
      */
     var $server_key_public_modulus;
@@ -316,8 +283,8 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getHostKeyPublicExponent()
-     * @var String
+     * @see self::getHostKeyPublicExponent()
+     * @var string
      * @access private
      */
     var $host_key_public_exponent;
@@ -327,8 +294,8 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getHostKeyPublicModulus()
-     * @var String
+     * @see self::getHostKeyPublicModulus()
+     * @var string
      * @access private
      */
     var $host_key_public_modulus;
@@ -338,18 +305,18 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getSupportedCiphers()
-     * @var Array
+     * @see self::getSupportedCiphers()
+     * @var array
      * @access private
      */
     var $supported_ciphers = array(
-        NET_SSH1_CIPHER_NONE       => 'No encryption',
-        NET_SSH1_CIPHER_IDEA       => 'IDEA in CFB mode',
-        NET_SSH1_CIPHER_DES        => 'DES in CBC mode',
-        NET_SSH1_CIPHER_3DES       => 'Triple-DES in CBC mode',
-        NET_SSH1_CIPHER_BROKEN_TSS => 'TRI\'s Simple Stream encryption CBC',
-        NET_SSH1_CIPHER_RC4        => 'RC4',
-        NET_SSH1_CIPHER_BLOWFISH   => 'Blowfish'
+        self::CIPHER_NONE       => 'No encryption',
+        self::CIPHER_IDEA       => 'IDEA in CFB mode',
+        self::CIPHER_DES        => 'DES in CBC mode',
+        self::CIPHER_3DES       => 'Triple-DES in CBC mode',
+        self::CIPHER_BROKEN_TSS => 'TRI\'s Simple Stream encryption CBC',
+        self::CIPHER_RC4        => 'RC4',
+        self::CIPHER_BLOWFISH   => 'Blowfish'
     );
 
     /**
@@ -357,99 +324,309 @@ class Net_SSH1 {
      *
      * Logged for debug purposes
      *
-     * @see Net_SSH1::getSupportedAuthentications()
-     * @var Array
+     * @see self::getSupportedAuthentications()
+     * @var array
      * @access private
      */
     var $supported_authentications = array(
-        NET_SSH1_AUTH_RHOSTS     => '.rhosts or /etc/hosts.equiv',
-        NET_SSH1_AUTH_RSA        => 'pure RSA authentication',
-        NET_SSH1_AUTH_PASSWORD   => 'password authentication',
-        NET_SSH1_AUTH_RHOSTS_RSA => '.rhosts with RSA host authentication'
+        self::AUTH_RHOSTS     => '.rhosts or /etc/hosts.equiv',
+        self::AUTH_RSA        => 'pure RSA authentication',
+        self::AUTH_PASSWORD   => 'password authentication',
+        self::AUTH_RHOSTS_RSA => '.rhosts with RSA host authentication'
     );
 
     /**
      * Server Identification
      *
-     * @see Net_SSH1::getServerIdentification()
-     * @var String
+     * @see self::getServerIdentification()
+     * @var string
      * @access private
      */
     var $server_identification = '';
 
     /**
+     * Protocol Flags
+     *
+     * @see self::__construct()
+     * @var array
+     * @access private
+     */
+    var $protocol_flags = array();
+
+    /**
+     * Protocol Flag Log
+     *
+     * @see self::getLog()
+     * @var array
+     * @access private
+     */
+    var $protocol_flag_log = array();
+
+    /**
+     * Message Log
+     *
+     * @see self::getLog()
+     * @var array
+     * @access private
+     */
+    var $message_log = array();
+
+    /**
+     * Real-time log file pointer
+     *
+     * @see self::_append_log()
+     * @var resource
+     * @access private
+     */
+    var $realtime_log_file;
+
+    /**
+     * Real-time log file size
+     *
+     * @see self::_append_log()
+     * @var int
+     * @access private
+     */
+    var $realtime_log_size;
+
+    /**
+     * Real-time log file wrap boolean
+     *
+     * @see self::_append_log()
+     * @var bool
+     * @access private
+     */
+    var $realtime_log_wrap;
+
+    /**
+     * Interactive Buffer
+     *
+     * @see self::read()
+     * @var array
+     * @access private
+     */
+    var $interactiveBuffer = '';
+
+    /**
+     * Timeout
+     *
+     * @see self::setTimeout()
+     * @access private
+     */
+    var $timeout;
+
+    /**
+     * Current Timeout
+     *
+     * @see self::_get_channel_packet()
+     * @access private
+     */
+    var $curTimeout;
+
+    /**
+     * Log Boundary
+     *
+     * @see self::_format_log()
+     * @access private
+     */
+    var $log_boundary = ':';
+
+    /**
+     * Log Long Width
+     *
+     * @see self::_format_log()
+     * @access private
+     */
+    var $log_long_width = 65;
+
+    /**
+     * Log Short Width
+     *
+     * @see self::_format_log()
+     * @access private
+     */
+    var $log_short_width = 16;
+
+    /**
+     * Hostname
+     *
+     * @see self::__construct()
+     * @see self::_connect()
+     * @var string
+     * @access private
+     */
+    var $host;
+
+    /**
+     * Port Number
+     *
+     * @see self::__construct()
+     * @see self::_connect()
+     * @var int
+     * @access private
+     */
+    var $port;
+
+    /**
+     * Timeout for initial connection
+     *
+     * Set by the constructor call. Calling setTimeout() is optional. If it's not called functions like
+     * exec() won't timeout unless some PHP setting forces it too. The timeout specified in the constructor,
+     * however, is non-optional. There will be a timeout, whether or not you set it. If you don't it'll be
+     * 10 seconds. It is used by fsockopen() in that function.
+     *
+     * @see self::__construct()
+     * @see self::_connect()
+     * @var int
+     * @access private
+     */
+    var $connectionTimeout;
+
+    /**
+     * Default cipher
+     *
+     * @see self::__construct()
+     * @see self::_connect()
+     * @var int
+     * @access private
+     */
+    var $cipher;
+
+    /**
      * Default Constructor.
      *
      * Connects to an SSHv1 server
      *
-     * @param String $host
-     * @param optional Integer $port
-     * @param optional Integer $timeout
-     * @param optional Integer $cipher
-     * @return Net_SSH1
+     * @param string $host
+     * @param int $port
+     * @param int $timeout
+     * @param int $cipher
+     * @return \phpseclib\Net\SSH1
      * @access public
      */
-    function Net_SSH1($host, $port = 22, $timeout = 10, $cipher = NET_SSH1_CIPHER_3DES)
+    function __construct($host, $port = 22, $timeout = 10, $cipher = self::CIPHER_3DES)
     {
-        $this->fsock = @fsockopen($host, $port, $errno, $errstr, $timeout);
+        $this->protocol_flags = array(
+            1  => 'NET_SSH1_MSG_DISCONNECT',
+            2  => 'NET_SSH1_SMSG_PUBLIC_KEY',
+            3  => 'NET_SSH1_CMSG_SESSION_KEY',
+            4  => 'NET_SSH1_CMSG_USER',
+            9  => 'NET_SSH1_CMSG_AUTH_PASSWORD',
+            10 => 'NET_SSH1_CMSG_REQUEST_PTY',
+            12 => 'NET_SSH1_CMSG_EXEC_SHELL',
+            13 => 'NET_SSH1_CMSG_EXEC_CMD',
+            14 => 'NET_SSH1_SMSG_SUCCESS',
+            15 => 'NET_SSH1_SMSG_FAILURE',
+            16 => 'NET_SSH1_CMSG_STDIN_DATA',
+            17 => 'NET_SSH1_SMSG_STDOUT_DATA',
+            18 => 'NET_SSH1_SMSG_STDERR_DATA',
+            19 => 'NET_SSH1_CMSG_EOF',
+            20 => 'NET_SSH1_SMSG_EXITSTATUS',
+            33 => 'NET_SSH1_CMSG_EXIT_CONFIRMATION'
+        );
+
+        $this->_define_array($this->protocol_flags);
+
+        $this->host = $host;
+        $this->port = $port;
+        $this->connectionTimeout = $timeout;
+        $this->cipher = $cipher;
+    }
+
+    /**
+     * Connect to an SSHv1 server
+     *
+     * @return bool
+     * @access private
+     */
+    function _connect()
+    {
+        $this->fsock = @fsockopen($this->host, $this->port, $errno, $errstr, $this->connectionTimeout);
         if (!$this->fsock) {
-            user_error(rtrim("Cannot connect to $host. Error $errno. $errstr"), E_USER_NOTICE);
-            return;
+            user_error(rtrim("Cannot connect to {$this->host}:{$this->port}. Error $errno. $errstr"));
+            return false;
         }
 
         $this->server_identification = $init_line = fgets($this->fsock, 255);
+
+        if (defined('NET_SSH1_LOGGING')) {
+            $this->_append_log('<-', $this->server_identification);
+            $this->_append_log('->', $this->identifier . "\r\n");
+        }
+
         if (!preg_match('#SSH-([0-9\.]+)-(.+)#', $init_line, $parts)) {
-            user_error('Can only connect to SSH servers', E_USER_NOTICE);
-            return;
+            user_error('Can only connect to SSH servers');
+            return false;
         }
         if ($parts[1][0] != 1) {
-            user_error("Cannot connect to SSH $parts[1] servers", E_USER_NOTICE);
-            return;
+            user_error("Cannot connect to SSH $parts[1] servers");
+            return false;
         }
 
         fputs($this->fsock, $this->identifier."\r\n");
 
         $response = $this->_get_binary_packet();
-        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_PUBLIC_KEY) {
-            user_error('Expected SSH_SMSG_PUBLIC_KEY', E_USER_NOTICE);
-            return;
+        if ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_PUBLIC_KEY) {
+            user_error('Expected SSH_SMSG_PUBLIC_KEY');
+            return false;
         }
 
-        $anti_spoofing_cookie = $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 8);
+        $anti_spoofing_cookie = $this->_string_shift($response[self::RESPONSE_DATA], 8);
 
-        $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4);
+        $this->_string_shift($response[self::RESPONSE_DATA], 4);
 
-        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
-        $server_key_public_exponent = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+        if (strlen($response[self::RESPONSE_DATA]) < 2) {
+            return false;
+        }
+        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
+        $server_key_public_exponent = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
         $this->server_key_public_exponent = $server_key_public_exponent;
 
-        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
-        $server_key_public_modulus = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+        if (strlen($response[self::RESPONSE_DATA]) < 2) {
+            return false;
+        }
+        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
+        $server_key_public_modulus = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+
         $this->server_key_public_modulus = $server_key_public_modulus;
 
-        $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4);
+        $this->_string_shift($response[self::RESPONSE_DATA], 4);
 
-        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
-        $host_key_public_exponent = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+        if (strlen($response[self::RESPONSE_DATA]) < 2) {
+            return false;
+        }
+        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
+        $host_key_public_exponent = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
         $this->host_key_public_exponent = $host_key_public_exponent;
 
-        $temp = unpack('nlen', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 2));
-        $host_key_public_modulus = new Math_BigInteger($this->_string_shift($response[NET_SSH1_RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+        if (strlen($response[self::RESPONSE_DATA]) < 2) {
+            return false;
+        }
+        $temp = unpack('nlen', $this->_string_shift($response[self::RESPONSE_DATA], 2));
+        $host_key_public_modulus = new BigInteger($this->_string_shift($response[self::RESPONSE_DATA], ceil($temp['len'] / 8)), 256);
+
         $this->host_key_public_modulus = $host_key_public_modulus;
 
-        $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4);
+        $this->_string_shift($response[self::RESPONSE_DATA], 4);
 
         // get a list of the supported ciphers
-        extract(unpack('Nsupported_ciphers_mask', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4)));
-        foreach ($this->supported_ciphers as $mask=>$name) {
+        if (strlen($response[self::RESPONSE_DATA]) < 4) {
+            return false;
+        }
+        extract(unpack('Nsupported_ciphers_mask', $this->_string_shift($response[self::RESPONSE_DATA], 4)));
+
+        foreach ($this->supported_ciphers as $mask => $name) {
             if (($supported_ciphers_mask & (1 << $mask)) == 0) {
                 unset($this->supported_ciphers[$mask]);
             }
         }
 
         // get a list of the supported authentications
-        extract(unpack('Nsupported_authentications_mask', $this->_string_shift($response[NET_SSH1_RESPONSE_DATA], 4)));
-        foreach ($this->supported_authentications as $mask=>$name) {
+        if (strlen($response[self::RESPONSE_DATA]) < 4) {
+            return false;
+        }
+        extract(unpack('Nsupported_authentications_mask', $this->_string_shift($response[self::RESPONSE_DATA], 4)));
+        foreach ($this->supported_authentications as $mask => $name) {
             if (($supported_authentications_mask & (1 << $mask)) == 0) {
                 unset($this->supported_authentications[$mask]);
             }
@@ -457,10 +634,7 @@ class Net_SSH1 {
 
         $session_id = pack('H*', md5($host_key_public_modulus->toBytes() . $server_key_public_modulus->toBytes() . $anti_spoofing_cookie));
 
-        $session_key = '';
-        for ($i = 0; $i < 32; $i++) {
-            $session_key.= chr(crypt_random(0, 255));
-        }
+        $session_key = Random::string(32);
         $double_encrypted_session_key = $session_key ^ str_pad($session_id, 32, chr(0));
 
         if ($server_key_public_modulus->compare($host_key_public_modulus) < 0) {
@@ -495,32 +669,32 @@ class Net_SSH1 {
             );
         }
 
-        $cipher = isset($this->supported_ciphers[$cipher]) ? $cipher : NET_SSH1_CIPHER_3DES;
+        $cipher = isset($this->supported_ciphers[$this->cipher]) ? $this->cipher : self::CIPHER_3DES;
         $data = pack('C2a*na*N', NET_SSH1_CMSG_SESSION_KEY, $cipher, $anti_spoofing_cookie, 8 * strlen($double_encrypted_session_key), $double_encrypted_session_key, 0);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_SESSION_KEY', E_USER_NOTICE);
-            return;
+            user_error('Error sending SSH_CMSG_SESSION_KEY');
+            return false;
         }
 
         switch ($cipher) {
-            //case NET_SSH1_CIPHER_NONE:
-            //    $this->crypto = new Crypt_Null();
+            //case self::CIPHER_NONE:
+            //    $this->crypto = new \phpseclib\Crypt\Null();
             //    break;
-            case NET_SSH1_CIPHER_DES:
-                $this->crypto = new Crypt_DES();
+            case self::CIPHER_DES:
+                $this->crypto = new DES();
                 $this->crypto->disablePadding();
                 $this->crypto->enableContinuousBuffer();
                 $this->crypto->setKey(substr($session_key, 0,  8));
                 break;
-            case NET_SSH1_CIPHER_3DES:
-                $this->crypto = new Crypt_TripleDES(CRYPT_DES_MODE_3CBC);
+            case self::CIPHER_3DES:
+                $this->crypto = new TripleDES(TripleDES::MODE_3CBC);
                 $this->crypto->disablePadding();
                 $this->crypto->enableContinuousBuffer();
                 $this->crypto->setKey(substr($session_key, 0, 24));
                 break;
-            //case NET_SSH1_CIPHER_RC4:
-            //    $this->crypto = new Crypt_RC4();
+            //case self::CIPHER_RC4:
+            //    $this->crypto = new RC4();
             //    $this->crypto->enableContinuousBuffer();
             //    $this->crypto->setKey(substr($session_key, 0,  16));
             //    break;
@@ -528,66 +702,100 @@ class Net_SSH1 {
 
         $response = $this->_get_binary_packet();
 
-        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
-            user_error('Expected SSH_SMSG_SUCCESS', E_USER_NOTICE);
-            return;
+        if ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
+            user_error('Expected SSH_SMSG_SUCCESS');
+            return false;
         }
 
-        $this->bitmap = NET_SSH1_MASK_CONSTRUCTOR;
+        $this->bitmap = self::MASK_CONNECTED;
+
+        return true;
     }
 
     /**
      * Login
      *
-     * @param String $username
-     * @param optional String $password
-     * @return Boolean
+     * @param string $username
+     * @param string $password
+     * @return bool
      * @access public
      */
     function login($username, $password = '')
     {
-        if (!($this->bitmap & NET_SSH1_MASK_CONSTRUCTOR)) {
+        if (!($this->bitmap & self::MASK_CONSTRUCTOR)) {
+            $this->bitmap |= self::MASK_CONSTRUCTOR;
+            if (!$this->_connect()) {
+                return false;
+            }
+        }
+
+        if (!($this->bitmap & self::MASK_CONNECTED)) {
             return false;
         }
 
         $data = pack('CNa*', NET_SSH1_CMSG_USER, strlen($username), $username);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_USER', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_USER');
             return false;
         }
 
         $response = $this->_get_binary_packet();
 
-        if ($response[NET_SSH1_RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
-            $this->bitmap |= NET_SSH1_MASK_LOGIN;
+        if ($response === true) {
+            return false;
+        }
+        if ($response[self::RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
+            $this->bitmap |= self::MASK_LOGIN;
             return true;
-        } else if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_FAILURE) {
-            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE', E_USER_NOTICE);
+        } elseif ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_FAILURE) {
+            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE');
             return false;
         }
 
         $data = pack('CNa*', NET_SSH1_CMSG_AUTH_PASSWORD, strlen($password), $password);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_AUTH_PASSWORD', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_AUTH_PASSWORD');
             return false;
         }
 
+        // remove the username and password from the last logged packet
+        if (defined('NET_SSH1_LOGGING') && NET_SSH1_LOGGING == self::LOG_COMPLEX) {
+            $data = pack('CNa*', NET_SSH1_CMSG_AUTH_PASSWORD, strlen('password'), 'password');
+            $this->message_log[count($this->message_log) - 1] = $data;
+        }
+
         $response = $this->_get_binary_packet();
 
-        if ($response[NET_SSH1_RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
-            $this->bitmap |= NET_SSH1_MASK_LOGIN;
+        if ($response === true) {
+            return false;
+        }
+        if ($response[self::RESPONSE_TYPE] == NET_SSH1_SMSG_SUCCESS) {
+            $this->bitmap |= self::MASK_LOGIN;
             return true;
-        } else if ($response[NET_SSH1_RESPONSE_TYPE] == NET_SSH1_SMSG_FAILURE) {
+        } elseif ($response[self::RESPONSE_TYPE] == NET_SSH1_SMSG_FAILURE) {
             return false;
         } else {
-            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE', E_USER_NOTICE);
+            user_error('Expected SSH_SMSG_SUCCESS or SSH_SMSG_FAILURE');
             return false;
         }
     }
 
     /**
+     * Set Timeout
+     *
+     * $ssh->exec('ping 127.0.0.1'); on a Linux host will never return and will run indefinitely.  setTimeout() makes it so it'll timeout.
+     * Setting $timeout to false or 0 will mean there is no timeout.
+     *
+     * @param mixed $timeout
+     */
+    function setTimeout($timeout)
+    {
+        $this->timeout = $this->curTimeout = $timeout;
+    }
+
+    /**
      * Executes a command on a non-interactive shell, returns the output, and quits.
      *
      * An SSH1 server will close the connection after a command has been executed on a non-interactive shell.  SSH2
@@ -597,54 +805,43 @@ class Net_SSH1 {
      * {@link http://www.faqs.org/docs/bashman/bashref_65.html http://www.faqs.org/docs/bashman/bashref_65.html}
      * {@link http://www.faqs.org/docs/bashman/bashref_62.html http://www.faqs.org/docs/bashman/bashref_62.html}
      *
-     * To execute further commands, a new Net_SSH1 object will need to be created.
+     * To execute further commands, a new \phpseclib\Net\SSH1 object will need to be created.
      *
      * Returns false on failure and the output, otherwise.
      *
-     * @see Net_SSH1::interactiveRead()
-     * @see Net_SSH1::interactiveWrite()
-     * @param String $cmd
+     * @see self::interactiveRead()
+     * @see self::interactiveWrite()
+     * @param string $cmd
      * @return mixed
      * @access public
      */
-    function exec($cmd)
+    function exec($cmd, $block = true)
     {
-        if (!($this->bitmap & NET_SSH1_MASK_LOGIN)) {
-            user_error('Operation disallowed prior to login()', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()');
             return false;
         }
 
-        // connect using the sample parameters in protocol-1.5.txt.
-        // according to wikipedia.org's entry on text terminals, "the fundamental type of application running on a text
-        // terminal is a command line interpreter or shell".  thus, opening a terminal session to run the shell.
-        $data = pack('CNa*N4C', NET_SSH1_CMSG_REQUEST_PTY, strlen('vt100'), 'vt100', 24, 80, 0, 0, NET_SSH1_TTY_OP_END);
+        $data = pack('CNa*', NET_SSH1_CMSG_EXEC_CMD, strlen($cmd), $cmd);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_REQUEST_PTY', E_USER_NOTICE);
-            return false;
-        }
-
-        $response = $this->_get_binary_packet();
-
-        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
-            user_error('Expected SSH_SMSG_SUCCESS', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_EXEC_CMD');
             return false;
         }
 
-        $data = pack('CNa*', NET_SSH1_CMSG_EXEC_CMD, strlen($cmd), $cmd);
-
-        if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_EXEC_CMD', E_USER_NOTICE);
-            return false;
+        if (!$block) {
+            return true;
         }
 
         $output = '';
         $response = $this->_get_binary_packet();
 
-        do {
-            $output.= substr($response[NET_SSH1_RESPONSE_DATA], 4);
-            $response = $this->_get_binary_packet();
-        } while ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_EXITSTATUS);
+        if ($response !== false) {
+            do {
+                $output.= substr($response[self::RESPONSE_DATA], 4);
+                $response = $this->_get_binary_packet();
+            } while (is_array($response) && $response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_EXITSTATUS);
+        }
 
         $data = pack('C', NET_SSH1_CMSG_EXIT_CONFIRMATION);
 
@@ -653,7 +850,7 @@ class Net_SSH1 {
 
         fclose($this->fsock);
 
-        // reset the execution bitmap - a new Net_SSH1 object needs to be created.
+        // reset the execution bitmap - a new \phpseclib\Net\SSH1 object needs to be created.
         $this->bitmap = 0;
 
         return $output;
@@ -662,35 +859,41 @@ class Net_SSH1 {
     /**
      * Creates an interactive shell
      *
-     * @see Net_SSH1::interactiveRead()
-     * @see Net_SSH1::interactiveWrite()
-     * @return Boolean
+     * @see self::interactiveRead()
+     * @see self::interactiveWrite()
+     * @return bool
      * @access private
      */
     function _initShell()
     {
-        $data = pack('CNa*N4C', NET_SSH1_CMSG_REQUEST_PTY, strlen('vt100'), 'vt100', 24, 80, 0, 0, NET_SSH1_TTY_OP_END);
+        // connect using the sample parameters in protocol-1.5.txt.
+        // according to wikipedia.org's entry on text terminals, "the fundamental type of application running on a text
+        // terminal is a command line interpreter or shell".  thus, opening a terminal session to run the shell.
+        $data = pack('CNa*N4C', NET_SSH1_CMSG_REQUEST_PTY, strlen('vt100'), 'vt100', 24, 80, 0, 0, self::TTY_OP_END);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_REQUEST_PTY', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_REQUEST_PTY');
             return false;
         }
 
         $response = $this->_get_binary_packet();
 
-        if ($response[NET_SSH1_RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
-            user_error('Expected SSH_SMSG_SUCCESS', E_USER_NOTICE);
+        if ($response === true) {
+            return false;
+        }
+        if ($response[self::RESPONSE_TYPE] != NET_SSH1_SMSG_SUCCESS) {
+            user_error('Expected SSH_SMSG_SUCCESS');
             return false;
         }
 
         $data = pack('C', NET_SSH1_CMSG_EXEC_SHELL);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_EXEC_SHELL', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_EXEC_SHELL');
             return false;
         }
 
-        $this->bitmap |= NET_SSH1_MASK_SHELL;
+        $this->bitmap |= self::MASK_SHELL;
 
         //stream_set_blocking($this->fsock, 0);
 
@@ -700,27 +903,83 @@ class Net_SSH1 {
     /**
      * Inputs a command into an interactive shell.
      *
-     * @see Net_SSH1::interactiveRead()
-     * @param String $cmd
-     * @return Boolean
+     * @see self::interactiveWrite()
+     * @param string $cmd
+     * @return bool
+     * @access public
+     */
+    function write($cmd)
+    {
+        return $this->interactiveWrite($cmd);
+    }
+
+    /**
+     * Returns the output of an interactive shell when there's a match for $expect
+     *
+     * $expect can take the form of a string literal or, if $mode == self::READ_REGEX,
+     * a regular expression.
+     *
+     * @see self::write()
+     * @param string $expect
+     * @param int $mode
+     * @return bool
+     * @access public
+     */
+    function read($expect, $mode = self::READ_SIMPLE)
+    {
+        if (!($this->bitmap & self::MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()');
+            return false;
+        }
+
+        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
+            user_error('Unable to initiate an interactive shell session');
+            return false;
+        }
+
+        $match = $expect;
+        while (true) {
+            if ($mode == self::READ_REGEX) {
+                preg_match($expect, $this->interactiveBuffer, $matches);
+                $match = isset($matches[0]) ? $matches[0] : '';
+            }
+            $pos = strlen($match) ? strpos($this->interactiveBuffer, $match) : false;
+            if ($pos !== false) {
+                return $this->_string_shift($this->interactiveBuffer, $pos + strlen($match));
+            }
+            $response = $this->_get_binary_packet();
+
+            if ($response === true) {
+                return $this->_string_shift($this->interactiveBuffer, strlen($this->interactiveBuffer));
+            }
+            $this->interactiveBuffer.= substr($response[self::RESPONSE_DATA], 4);
+        }
+    }
+
+    /**
+     * Inputs a command into an interactive shell.
+     *
+     * @see self::interactiveRead()
+     * @param string $cmd
+     * @return bool
      * @access public
      */
     function interactiveWrite($cmd)
     {
-        if (!($this->bitmap & NET_SSH1_MASK_LOGIN)) {
-            user_error('Operation disallowed prior to login()', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()');
             return false;
         }
 
-        if (!($this->bitmap & NET_SSH1_MASK_SHELL) && !$this->_initShell()) {
-            user_error('Unable to initiate an interactive shell session', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
+            user_error('Unable to initiate an interactive shell session');
             return false;
         }
 
         $data = pack('CNa*', NET_SSH1_CMSG_STDIN_DATA, strlen($cmd), $cmd);
 
         if (!$this->_send_binary_packet($data)) {
-            user_error('Error sending SSH_CMSG_STDIN', E_USER_NOTICE);
+            user_error('Error sending SSH_CMSG_STDIN');
             return false;
         }
 
@@ -728,27 +987,27 @@ class Net_SSH1 {
     }
 
     /**
-     * Reads the output of an interactive shell.
+     * Returns the output of an interactive shell when no more output is available.
      *
      * Requires PHP 4.3.0 or later due to the use of the stream_select() function.  If you see stuff like
-     * "[00m", you're seeing ANSI escape codes.  According to
+     * "^[[00m", you're seeing ANSI escape codes.  According to
      * {@link http://support.microsoft.com/kb/101875 How to Enable ANSI.SYS in a Command Window}, "Windows NT
      * does not support ANSI escape sequences in Win32 Console applications", so if you're a Windows user,
      * there's not going to be much recourse.
      *
-     * @see Net_SSH1::interactiveRead()
-     * @return String
+     * @see self::interactiveRead()
+     * @return string
      * @access public
      */
     function interactiveRead()
     {
-        if (!($this->bitmap & NET_SSH1_MASK_LOGIN)) {
-            user_error('Operation disallowed prior to login()', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_LOGIN)) {
+            user_error('Operation disallowed prior to login()');
             return false;
         }
 
-        if (!($this->bitmap & NET_SSH1_MASK_SHELL) && !$this->_initShell()) {
-            user_error('Unable to initiate an interactive shell session', E_USER_NOTICE);
+        if (!($this->bitmap & self::MASK_SHELL) && !$this->_initShell()) {
+            user_error('Unable to initiate an interactive shell session');
             return false;
         }
 
@@ -756,7 +1015,7 @@ class Net_SSH1 {
         $write = $except = null;
         if (stream_select($read, $write, $except, 0)) {
             $response = $this->_get_binary_packet();
-            return substr($response[NET_SSH1_RESPONSE_DATA], 4);
+            return substr($response[self::RESPONSE_DATA], 4);
         } else {
             return '';
         }
@@ -788,13 +1047,29 @@ class Net_SSH1 {
     /**
      * Disconnect
      *
-     * @param String $msg
+     * @param string $msg
      * @access private
      */
     function _disconnect($msg = 'Client Quit')
     {
         if ($this->bitmap) {
+            $data = pack('C', NET_SSH1_CMSG_EOF);
+            $this->_send_binary_packet($data);
+            /*
+            $response = $this->_get_binary_packet();
+            if ($response === true) {
+                $response = array(self::RESPONSE_TYPE => -1);
+            }
+            switch ($response[self::RESPONSE_TYPE]) {
+                case NET_SSH1_SMSG_EXITSTATUS:
+                    $data = pack('C', NET_SSH1_CMSG_EXIT_CONFIRMATION);
+                    break;
+                default:
+                    $data = pack('CNa*', NET_SSH1_MSG_DISCONNECT, strlen($msg), $msg);
+            }
+            */
             $data = pack('CNa*', NET_SSH1_MSG_DISCONNECT, strlen($msg), $msg);
+
             $this->_send_binary_packet($data);
             fclose($this->fsock);
             $this->bitmap = 0;
@@ -809,25 +1084,52 @@ class Net_SSH1 {
      * Also, this function could be improved upon by adding detection for the following exploit:
      * http://www.securiteam.com/securitynews/5LP042K3FY.html
      *
-     * @see Net_SSH1::_send_binary_packet()
-     * @return Array
+     * @see self::_send_binary_packet()
+     * @return array
      * @access private
      */
     function _get_binary_packet()
     {
         if (feof($this->fsock)) {
-            //user_error('connection closed prematurely', E_USER_NOTICE);
+            //user_error('connection closed prematurely');
             return false;
         }
 
-        $temp = unpack('Nlength', fread($this->fsock, 4));
+        if ($this->curTimeout) {
+            $read = array($this->fsock);
+            $write = $except = null;
+
+            $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
+            $sec = floor($this->curTimeout);
+            $usec = 1000000 * ($this->curTimeout - $sec);
+            // on windows this returns a "Warning: Invalid CRT parameters detected" error
+            if (!@stream_select($read, $write, $except, $sec, $usec) && !count($read)) {
+                //$this->_disconnect('Timeout');
+                return true;
+            }
+            $elapsed = strtok(microtime(), ' ') + strtok('') - $start;
+            $this->curTimeout-= $elapsed;
+        }
+
+        $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
+        $data = fread($this->fsock, 4);
+        if (strlen($data) < 4) {
+            return false;
+        }
+        $temp = unpack('Nlength', $data);
 
         $padding_length = 8 - ($temp['length'] & 7);
         $length = $temp['length'] + $padding_length;
+        $raw = '';
 
-        $raw = fread($this->fsock, $length);
+        while ($length > 0) {
+            $temp = fread($this->fsock, $length);
+            $raw.= $temp;
+            $length-= strlen($temp);
+        }
+        $stop = strtok(microtime(), ' ') + strtok('');
 
-        if ($this->crypto !== false) {
+        if (strlen($raw) && $this->crypto !== false) {
             $raw = $this->crypto->decrypt($raw);
         }
 
@@ -835,16 +1137,28 @@ class Net_SSH1 {
         $type = $raw[$padding_length];
         $data = substr($raw, $padding_length + 1, -4);
 
+        if (strlen($raw) < 4) {
+            return false;
+        }
         $temp = unpack('Ncrc', substr($raw, -4));
 
         //if ( $temp['crc'] != $this->_crc($padding . $type . $data) ) {
-        //    user_error('Bad CRC in packet from server', E_USER_NOTICE);
+        //    user_error('Bad CRC in packet from server');
         //    return false;
         //}
 
+        $type = ord($type);
+
+        if (defined('NET_SSH1_LOGGING')) {
+            $temp = isset($this->protocol_flags[$type]) ? $this->protocol_flags[$type] : 'UNKNOWN';
+            $temp = '<- ' . $temp .
+                    ' (' . round($stop - $start, 4) . 's)';
+            $this->_append_log($temp, $data);
+        }
+
         return array(
-            NET_SSH1_RESPONSE_TYPE => ord($type),
-            NET_SSH1_RESPONSE_DATA => $data
+            self::RESPONSE_TYPE => $type,
+            self::RESPONSE_DATA => $data
         );
     }
 
@@ -853,25 +1167,23 @@ class Net_SSH1 {
      *
      * Returns true on success, false on failure.
      *
-     * @see Net_SSH1::_get_binary_packet()
-     * @param String $data
-     * @return Boolean
+     * @see self::_get_binary_packet()
+     * @param string $data
+     * @return bool
      * @access private
      */
-    function _send_binary_packet($data) {
+    function _send_binary_packet($data)
+    {
         if (feof($this->fsock)) {
-            //user_error('connection closed prematurely', E_USER_NOTICE);
+            //user_error('connection closed prematurely');
             return false;
         }
 
         $length = strlen($data) + 4;
 
-        $padding_length = 8 - ($length & 7);
-        $padding = '';
-        for ($i = 0; $i < $padding_length; $i++) {
-            $padding.= chr(crypt_random(0, 255));
-        }
+        $padding = Random::string(8 - ($length & 7));
 
+        $orig = $data;
         $data = $padding . $data;
         $data.= pack('N', $this->_crc($data));
 
@@ -881,7 +1193,18 @@ class Net_SSH1 {
 
         $packet = pack('Na*', $length, $data);
 
-        return strlen($packet) == fputs($this->fsock, $packet);
+        $start = strtok(microtime(), ' ') + strtok(''); // http://php.net/microtime#61838
+        $result = strlen($packet) == fputs($this->fsock, $packet);
+        $stop = strtok(microtime(), ' ') + strtok('');
+
+        if (defined('NET_SSH1_LOGGING')) {
+            $temp = isset($this->protocol_flags[ord($orig[0])]) ? $this->protocol_flags[ord($orig[0])] : 'UNKNOWN';
+            $temp = '-> ' . $temp .
+                    ' (' . round($stop - $start, 4) . 's)';
+            $this->_append_log($temp, $orig);
+        }
+
+        return $result;
     }
 
     /**
@@ -891,10 +1214,10 @@ class Net_SSH1 {
      * we've reimplemented it. A more detailed discussion of the differences can be found after
      * $crc_lookup_table's initialization.
      *
-     * @see Net_SSH1::_get_binary_packet()
-     * @see Net_SSH1::_send_binary_packet()
-     * @param String $data
-     * @return Integer
+     * @see self::_get_binary_packet()
+     * @see self::_send_binary_packet()
+     * @param string $data
+     * @return int
      * @access private
      */
     function _crc($data)
@@ -971,7 +1294,7 @@ class Net_SSH1 {
         $crc = 0x00000000;
         $length = strlen($data);
 
-        for ($i=0;$i<$length;$i++) {
+        for ($i=0; $i<$length; $i++) {
             // We AND $crc >> 8 with 0x00FFFFFF because we want the eight newly added bits to all
             // be zero.  PHP, unfortunately, doesn't always do this.  0x80000000 >> 8, as an example,
             // yields 0xFF800000 - not 0x00800000.  The following link elaborates:
@@ -989,9 +1312,9 @@ class Net_SSH1 {
      *
      * Inspired by array_shift
      *
-     * @param String $string
-     * @param optional Integer $index
-     * @return String
+     * @param string $string
+     * @param int $index
+     * @return string
      * @access private
      */
     function _string_shift(&$string, $index = 1)
@@ -1008,22 +1331,18 @@ class Net_SSH1 {
      * should be a number with the property that gcd($e, ($p - 1) * ($q - 1)) == 1.  Could just make anything that
      * calls this call modexp, instead, but I think this makes things clearer, maybe...
      *
-     * @see Net_SSH1::Net_SSH1()
-     * @param Math_BigInteger $m
-     * @param Array $key
-     * @return Math_BigInteger
+     * @see self::__construct()
+     * @param BigInteger $m
+     * @param array $key
+     * @return BigInteger
      * @access private
      */
     function _rsa_crypt($m, $key)
     {
         /*
-        if (!class_exists('Crypt_RSA')) {
-            require_once('Crypt/RSA.php');
-        }
-
-        $rsa = new Crypt_RSA();
-        $rsa->loadKey($key, CRYPT_RSA_PUBLIC_FORMAT_RAW);
-        $rsa->setEncryptionMode(CRYPT_RSA_ENCRYPTION_PKCS1);
+        $rsa = new RSA();
+        $rsa->loadKey($key, RSA::PUBLIC_FORMAT_RAW);
+        $rsa->setEncryptionMode(RSA::ENCRYPTION_PKCS1);
         return $rsa->encrypt($m);
         */
 
@@ -1040,28 +1359,128 @@ class Net_SSH1 {
         // Presumably the part of PKCS#1 they're refering to is "Section 7.2.1 Encryption Operation",
         // under "7.2 RSAES-PKCS1-v1.5" and "7 Encryption schemes" of the following URL:
         // ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf
-        $temp = chr(0) . chr(2);
         $modulus = $key[1]->toBytes();
         $length = strlen($modulus) - strlen($m) - 3;
-        for ($i = 0; $i < $length; $i++) {
-            $temp.= chr(crypt_random(1, 255));
+        $random = '';
+        while (strlen($random) != $length) {
+            $block = Random::string($length - strlen($random));
+            $block = str_replace("\x00", '', $block);
+            $random.= $block;
         }
-        $temp.= chr(0) . $m;
+        $temp = chr(0) . chr(2) . $random . chr(0) . $m;
 
-        $m = new Math_BigInteger($temp, 256);
+        $m = new BigInteger($temp, 256);
         $m = $m->modPow($key[0], $key[1]);
 
         return $m->toBytes();
     }
 
     /**
+     * Define Array
+     *
+     * Takes any number of arrays whose indices are integers and whose values are strings and defines a bunch of
+     * named constants from it, using the value as the name of the constant and the index as the value of the constant.
+     * If any of the constants that would be defined already exists, none of the constants will be defined.
+     *
+     * @param array $array
+     * @access private
+     */
+    function _define_array()
+    {
+        $args = func_get_args();
+        foreach ($args as $arg) {
+            foreach ($arg as $key => $value) {
+                if (!defined($value)) {
+                    define($value, $key);
+                } else {
+                    break 2;
+                }
+            }
+        }
+    }
+
+    /**
+     * Returns a log of the packets that have been sent and received.
+     *
+     * Returns a string if NET_SSH1_LOGGING == self::LOG_COMPLEX, an array if NET_SSH1_LOGGING == self::LOG_SIMPLE and false if !defined('NET_SSH1_LOGGING')
+     *
+     * @access public
+     * @return array|false|string
+     */
+    function getLog()
+    {
+        if (!defined('NET_SSH1_LOGGING')) {
+            return false;
+        }
+
+        switch (NET_SSH1_LOGGING) {
+            case self::LOG_SIMPLE:
+                return $this->message_number_log;
+                break;
+            case self::LOG_COMPLEX:
+                return $this->_format_log($this->message_log, $this->protocol_flags_log);
+                break;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Formats a log for printing
+     *
+     * @param array $message_log
+     * @param array $message_number_log
+     * @access private
+     * @return string
+     */
+    function _format_log($message_log, $message_number_log)
+    {
+        $output = '';
+        for ($i = 0; $i < count($message_log); $i++) {
+            $output.= $message_number_log[$i] . "\r\n";
+            $current_log = $message_log[$i];
+            $j = 0;
+            do {
+                if (strlen($current_log)) {
+                    $output.= str_pad(dechex($j), 7, '0', STR_PAD_LEFT) . '0  ';
+                }
+                $fragment = $this->_string_shift($current_log, $this->log_short_width);
+                $hex = substr(preg_replace_callback('#.#s', array($this, '_format_log_helper'), $fragment), strlen($this->log_boundary));
+                // replace non ASCII printable characters with dots
+                // http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
+                // also replace < with a . since < messes up the output on web browsers
+                $raw = preg_replace('#[^\x20-\x7E]|<#', '.', $fragment);
+                $output.= str_pad($hex, $this->log_long_width - $this->log_short_width, ' ') . $raw . "\r\n";
+                $j++;
+            } while (strlen($current_log));
+            $output.= "\r\n";
+        }
+
+        return $output;
+    }
+
+    /**
+     * Helper function for _format_log
+     *
+     * For use with preg_replace_callback()
+     *
+     * @param array $matches
+     * @access private
+     * @return string
+     */
+    function _format_log_helper($matches)
+    {
+        return $this->log_boundary . str_pad(dechex(ord($matches[0])), 2, '0', STR_PAD_LEFT);
+    }
+
+    /**
      * Return the server key public exponent
      *
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param optional Boolean $raw_output
-     * @return String
+     * @param bool $raw_output
+     * @return string
      * @access public
      */
     function getServerKeyPublicExponent($raw_output = false)
@@ -1075,8 +1494,8 @@ class Net_SSH1 {
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param optional Boolean $raw_output
-     * @return String
+     * @param bool $raw_output
+     * @return string
      * @access public
      */
     function getServerKeyPublicModulus($raw_output = false)
@@ -1090,8 +1509,8 @@ class Net_SSH1 {
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param optional Boolean $raw_output
-     * @return String
+     * @param bool $raw_output
+     * @return string
      * @access public
      */
     function getHostKeyPublicExponent($raw_output = false)
@@ -1105,8 +1524,8 @@ class Net_SSH1 {
      * Returns, by default, the base-10 representation.  If $raw_output is set to true, returns, instead,
      * the raw bytes.  This behavior is similar to PHP's md5() function.
      *
-     * @param optional Boolean $raw_output
-     * @return String
+     * @param bool $raw_output
+     * @return string
      * @access public
      */
     function getHostKeyPublicModulus($raw_output = false)
@@ -1119,10 +1538,10 @@ class Net_SSH1 {
      *
      * Just because a cipher is supported by an SSH1 server doesn't mean it's supported by this library. If $raw_output
      * is set to true, returns, instead, an array of constants.  ie. instead of array('Triple-DES in CBC mode'), you'll
-     * get array(NET_SSH1_CIPHER_3DES).
+     * get array(self::CIPHER_3DES).
      *
-     * @param optional Boolean $raw_output
-     * @return Array
+     * @param bool $raw_output
+     * @return array
      * @access public
      */
     function getSupportedCiphers($raw_output = false)
@@ -1135,10 +1554,10 @@ class Net_SSH1 {
      *
      * Just because a cipher is supported by an SSH1 server doesn't mean it's supported by this library. If $raw_output
      * is set to true, returns, instead, an array of constants.  ie. instead of array('password authentication'), you'll
-     * get array(NET_SSH1_AUTH_PASSWORD).
+     * get array(self::AUTH_PASSWORD).
      *
-     * @param optional Boolean $raw_output
-     * @return Array
+     * @param bool $raw_output
+     * @return array
      * @access public
      */
     function getSupportedAuthentications($raw_output = false)
@@ -1149,11 +1568,75 @@ class Net_SSH1 {
     /**
      * Return the server identification.
      *
-     * @return String
+     * @return string
      * @access public
      */
     function getServerIdentification()
     {
         return rtrim($this->server_identification);
     }
+
+    /**
+     * Logs data packets
+     *
+     * Makes sure that only the last 1MB worth of packets will be logged
+     *
+     * @param string $data
+     * @access private
+     */
+    function _append_log($protocol_flags, $message)
+    {
+        switch (NET_SSH1_LOGGING) {
+            // useful for benchmarks
+            case self::LOG_SIMPLE:
+                $this->protocol_flags_log[] = $protocol_flags;
+                break;
+            // the most useful log for SSH1
+            case self::LOG_COMPLEX:
+                $this->protocol_flags_log[] = $protocol_flags;
+                $this->_string_shift($message);
+                $this->log_size+= strlen($message);
+                $this->message_log[] = $message;
+                while ($this->log_size > self::LOG_MAX_SIZE) {
+                    $this->log_size-= strlen(array_shift($this->message_log));
+                    array_shift($this->protocol_flags_log);
+                }
+                break;
+            // dump the output out realtime; packets may be interspersed with non packets,
+            // passwords won't be filtered out and select other packets may not be correctly
+            // identified
+            case self::LOG_REALTIME:
+                echo "<pre>\r\n" . $this->_format_log(array($message), array($protocol_flags)) . "\r\n</pre>\r\n";
+                @flush();
+                @ob_flush();
+                break;
+            // basically the same thing as self::LOG_REALTIME with the caveat that self::LOG_REALTIME_FILE
+            // needs to be defined and that the resultant log file will be capped out at self::LOG_MAX_SIZE.
+            // the earliest part of the log file is denoted by the first <<< START >>> and is not going to necessarily
+            // at the beginning of the file
+            case self::LOG_REALTIME_FILE:
+                if (!isset($this->realtime_log_file)) {
+                    // PHP doesn't seem to like using constants in fopen()
+                    $filename = self::LOG_REALTIME_FILE;
+                    $fp = fopen($filename, 'w');
+                    $this->realtime_log_file = $fp;
+                }
+                if (!is_resource($this->realtime_log_file)) {
+                    break;
+                }
+                $entry = $this->_format_log(array($message), array($protocol_flags));
+                if ($this->realtime_log_wrap) {
+                    $temp = "<<< START >>>\r\n";
+                    $entry.= $temp;
+                    fseek($this->realtime_log_file, ftell($this->realtime_log_file) - strlen($temp));
+                }
+                $this->realtime_log_size+= strlen($entry);
+                if ($this->realtime_log_size > self::LOG_MAX_SIZE) {
+                    fseek($this->realtime_log_file, 0);
+                    $this->realtime_log_size = strlen($entry);
+                    $this->realtime_log_wrap = true;
+                }
+                fputs($this->realtime_log_file, $entry);
+        }
+    }
 }
